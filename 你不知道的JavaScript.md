# 第一部分  作用域和闭包

## 第1章、作用域是什么？

### 是什么？

​	**作用域**是一套规则，用于确定在何处以及如何查找变量 （变量）。也就是说用来明确变量的作用范围。

### LHS、RHS

​	“L”，“R”分别代表左侧和右侧，当变量出现在赋值操作的左侧时进行`LHS` 查询，出现在右侧时进行`RHS` 查询。

​	你也可以将 RHS 理解成 retrieve his source value（取到它的源值）。

​	总之，如果查找的目的是对变量进行赋值，那么就会使用 `LHS` 查询；如果目的是获取变量的值，就会使用 `RHS` 查询。

例如：

```js
function foo(a) {
    var b = a; 
    return a + b;
}
var c = foo( 2 );
```

​	这段代码将会进行3次 `LHS` 查询，4次 `RHS` 查询。

​	当执行这段代码时，首先是对于foo的 `RHS` 查询，查找到一个函数并使用，这里有一个隐式赋值a = 2，这里会进行一次 `LHS` 查询，然后执行函数内部的语句，对a的两次 `RHS` ，对b的一次 `LHS` 一次 `RHS` ，最后是返回值后对c的一次 `LHS` 查询。

### var a = 1，JS引擎会干什么？

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（去上级作用域中查找），如果没找到则会异常。

### 异常

**ReferenceError（引用错误）：**

​	当对一个变量进行RHS查询时，找不到所需变量，引擎就会抛出一个ReferenceError（引用错误）的异常。

​	而对于LHS查询，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会自动创建一个具有该名称的变量，并将其返回给引擎使用，前提是程序运行在非 ‘严格模式’ 下。

​	ES5引入了 ‘严格模式’ ，其中一个规范就是禁止自动或隐式地创建全局变量。这时，再进行LHS时就会像RHS查询一样抛出一个ReferenceError（引用错误）的异常。

**TypeError（类型错误）：**

​	如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作。

​	比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

**总结**

​	ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 第2章、词法作用域

​	作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的`词法作用域`，我们会对这种作用域进行深入讨论。另外一种叫作`动态作用域`，仍有一些编程语言在使用（比如Bash 脚本、Perl 中的一些模式等）。

```js
var a = 2;

function foo() {
  console.log(a); // 会输出2还是3？
}

function bar() {
  var a = 3;
  foo();
}

bar();

/*
	这里只是简单举例！！
	如果这里使用的是词法作用域，那么foo函数的上级作用域就是全局作用域，那么会输出2。
	而如果这里是动态作用域，它并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。因此这里会输出3
*/
```

[词法作用域 VS 动态作用域](https://www.jianshu.com/p/70b38c7ab69c)

### 词法作用域是什么？

​	简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

### 欺骗词法

​	**首先，欺骗词法作用域会导致性能 下降。**

​	有两种欺骗作用域的机制：

- eval

  ​	JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并
  运行，就好像代码是写在那个位置的一样。

  *比如：*

  ```js
  function fn(str){
      eval(str)
      console.log(b);
  }
  var b = 1;
  fn('var b = 2;');
  
  // 对于这段代码来说，正常情况下应该输出1，但是由于eval的特性，会修改fn的作用域，在fn中重新声明了一个变量b，这样会遮蔽上级中的b，因此结果会输出2。
  ```

- with

  ​	with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

  ​	with 块可以将一个对象处理为词法作用域。这里不做深究。

### 性能

​	JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

​	最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

​	如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。

​	在`严格模式`下，with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
eval(..) 也被禁止了。因此，不要使用它们。

## 第3章、函数作用域和块作用域

