# 参考

[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

[（完整版）快速掌握虚拟DOM和diff算法【Vue】](https://www.bilibili.com/video/BV1dV411a7mT)

[vue核心之虚拟DOM(vdom)](https://www.jianshu.com/p/af0b398602bc)

[传统Diff算法为什么时间复杂度要O(n ^3)](https://juejin.cn/post/6892671384976097287)

# 一、真实DOM和其解析流程？ 

  浏览器渲染引擎工作流程都差不多，大致分为5步，**创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting**

  第一步，用HTML分析器，分析HTML元素，**构建一颗DOM树**(标记化和树构建)。

  第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。

  第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有**attach方法，接受样式信息**，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。

  第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。

  第五步，Render树和节点显示坐标都有了，就调用每个节点**paint方法，把它们绘制**出来。 

  **DOM树的构建是文档加载完成开始的？**构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。**它不必**等到整个HTML文档解析完毕之后才开始构建render数和布局。

  **Render树是DOM树和CSSOM树构建完毕才开始构建的吗？**这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。

  **CSS的解析是从右往左逆向解析的**(从DOM树的下－上解析比上－下解析效率高)，**嵌套标签越多，解析越慢。**

![img](https:////upload-images.jianshu.io/upload_images/4345378-b7ccad3bc808783f.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

<center style="color:#C0C0C0;text-decoration:underline">webkit渲染引擎工作流程</center>

# 二、JS操作真实DOM的代价！

​    用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。

# 三、Virtual dom（虚拟dom）

*数据驱动视图*

## 什么是虚拟dom？虚拟dom的好处

 	Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，

​    虚拟DOM就是为了**解决浏览器性能问题**而被设计出来的。**如前**，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个**JS对象**中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。**所以，**用JS对象模拟DOM节点的好处是，**页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。**

# 四、diff算法

​	 两棵树如果完全比较时间复杂度是O(n^3)，但参照《深入浅出React和Redux》一书中的介绍，React的Diff算法的时间复杂度是O(n)。要实现这么低的时间复杂度，意味着只能平层的比较两棵树的节点，放弃了深度遍历。这样做，似乎牺牲掉了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层移动DOM元素，这样做是最优的。所以React工程师们优化这个算法。给diff算法增加了几条规则：
1、只进行同级比较，不跨级比较
2、当标签的类型（tag，例如div和span是两个类型的标签）改变，则直接删除重新加载渲染，不再深度比较。
3、当tag和key(key,和for循环中的key是相同的，key作为每一个标签的唯一标识，可以优化diff算法)，两者相同的时候，则认为是相同的，不在进行深入的比较。

 平层Diff，只有以下4种情况：

​    1、**节点类型变了**，例如下图中的P变成了H3。我们将这个过程称之为**REPLACE**。直接将旧节点卸载并装载新节点。旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做效率不高。但为了避免O(n^3)的时间复杂度，这样是值得的。这也提醒了开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p没有意义。

​    2、**节点类型一样，仅仅属性或属性值变了。**我们将这个过程称之为**PROPS**。此时不会触发节点卸载和装载，而是节点更新。

​    3、**文本变了**，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为**TEXT**。

​    4、**移动／增加／删除 子节点**，我们将这个过程称之为**REORDER**。看一个例子，在A、B、C、D、E五个节点的
